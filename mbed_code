
#include "mbed.h"
#include <exception>
#include <cstdio>
#include <Ticker.h>

#define TI_driving 0.001f          // 1kHz sample time
#define TI_steering 0.01f   // 50 Hz sample time
#define Vbat 7.2f           // Battery voltage

// Steering variables
bool new_steering_update = false; // flag for recalculating steering feedback
bool left_landmark_detected = false;
bool right_landmark_detected = false;

//First straightaway (left = 0, right = 0)
float Sect1_speed = 0.225;
float Sect1KP_steering = 0.0128;
float Sect1KI_steering = 0.007;
float Sect1KD_steering = 0.0001165;

//preliminary slow down on straight same gains (left = 0, right = 1)
float Sect2_speed = 0.15;
float Sect2KP_steering = 0.04;
float Sect2KI_steering = 0.0068;
float Sect2KD_steering = 0.0001165;

//start corner 1 (left = 1, right = 1)
float Sect3_speed = 0.175;
float Sect3KP_steering = 0.09;
float Sect3KI_steering = 0.0085;
float Sect3KD_steering = 0.000005;

//Start hairpin (left = 1, right = 3)
float Hairpin1_speed = 0.18;
float Hairpin1KP_steering = 0.0955; //0.095
float Hairpin1KI_steering = 0.03; 
float Hairpin1KD_steering = 0.000005;

// second half of hairpin (left = 2, right = 3)
float Hairpin2_speed = 0.18;
float Hairpin2KP_steering = 0.0985; //0.095
float Hairpin2KI_steering = 0.01; 
float Hairpin2KD_steering = 0.0001;

//corner 2 out of hairpin (left = 3, right = 3)
float Sect4_speed = 0.175;
float Sect4KP_steering = 0.095; 
float Sect4KI_steering = 0.0085; 
float Sect4KD_steering = 0.000005;

//2ndStraigtaway (left = 3, right = 4)
float Sect5_speed = 0.225;
float Sect5KP_steering = 0.04; 
float Sect5KI_steering = 0.00425; 
float Sect5KD_steering = 0.0;

//corner 3 (left = 4, right = 4)
float Sect6_speed = 0.175;
float Sect6KP_steering = 0.065; 
float Sect6KI_steering = 0.0065; 
float Sect6KD_steering = 0.000005;

// straight by power station (left = 4, right = 5)
float Sect7_speed = 0.175;
float Sect7KP_steering = 0.095; 
float Sect7KI_steering = 0.0085; 
float Sect7KD_steering = 0.000005;

// turn right before double tape (left = 5, right = 5)
float Sect8_speed = 0.15;
float Sect8KP_steering = 0.105; 
float Sect8KI_steering = 0.0085;
float Sect8KD_steering = 0.000005;

////////////////////////////////////////////////////////////////////
////////////////////*INITIALIZE VARIABLES*//////////////////////////
// initialize positioning on track
int num_left_landmarks = 1; // 1 (for section 3)
int num_right_landmarks = 1; // 1 (for section 3)
// set initial speed and gains for section three (after the straightaway)
float initialSpeed = Sect1_speed;
float KP_steering = Sect3KP_steering; 
float KI_steering = Sect3KI_steering; 
float KD_steering = Sect3KD_steering; 
////////////////////////////////////////////////////////////////////

float error_current_steering = 0; // error term
float feedback = 0; // feedback value from inductive sensors
float controlAction = 0.0; // control action from steering controller
float previousError = 0.0;
float errorChange = 0.0;
float integralSum = 0.0; // Area prior
float controllerOutput = 0.0;
float reference = 0.0;
float senSlope = 10; //13
float center = 0.066; // 0.066
float control_threshold = 0.01; //0.01 percent change that must occur for steering control to implement
float steering_bias_constant = 0; // constant that is added to the value from right inductive sensor to center the car

DigitalIn right_bumper(D2);
DigitalIn left_bumper(D8);
AnalogIn inductor1(A4); // input from inductor 1 (left)
AnalogIn inductor2(A0); // input from inductor 2 (right)
AnalogIn detectLeft(A2);
AnalogIn detectRight(A3);
PwmOut servo(D5); // PWM output to servo
DigitalOut runLED(D7); // indicator LED
DigitalOut landmarkLED(D4); // turns on and off each section to indicate landmark detection is working
DigitalOut brakeCircuit(D3); // opens N channel mosfet to divert power from motor and brake quickly

// Driving variables
float slowSpeed = 0.175;
float ExtraslowSpeed = 0.15;
float fastSpeed = 0.25;
float targetSpeed = 0;
float KP_driving = 2;   // Proportional gain
float KI_driving = 1; //1.674;   // Integral gain
float KD_driving = 0;
float output = 0;
float bound_output = 0;
float current_speed = 0;
float error_current = 0;
float driving_bias_constant = 0;

AnalogIn driving_sensor(A5);     // Sensor reading speed feedback
PwmOut control_output(D6);        // PWM output to control system

// State conditions
bool buttonPressed = false;
bool programRunning = false;

// Function to calculate the integral term using Euler forward approximation
float calculateIntegral(float error_current, float area_prior, float sample_time) {
   // Integral approximation: area_current = area_prior + (error_current * DT)
   float area_current = area_prior + (error_current * sample_time);
   
   // Update the area prior variable for the next iteration
   area_prior = area_current;
   
   return area_current;
}

// Function to calculate the derivative term using a first-order Taylor series approximation
float calculateDerivative(float error_current, float error_prior, float sample_time) {
   // Derivative approximation: (error_current - error_prior) / DT
   return (error_current - error_prior) / sample_time;
}

// Function to calculate the PID
float calculatePIDOutput(float sample_time, float error_current, float error_prior, float area_prior, float kp, float ki, float kd){

   // Calculate the integral approximation of the error curve up to the current time.
   float area_current = calculateIntegral(error_current, sample_time, area_prior);

   // Calculate the derivative approximation of the error curve at the current time.
   float error_change = calculateDerivative(error_current, error_prior, sample_time);

   // Calculate the Control Action using the PID Equation
   float action = kp*error_current + ki*area_current + kd*error_change;

   return action;

}

// Takes the average of however many samples from the left and right sensors before calculating sensor feedback
void get_steering_feedback() {

    // read left and right steering sensors
    float left_sensor_sum = 0;
    float right_sensor_sum = 0;
    int samples = 2;
    for (int i = 0; i < samples; i++) {
        left_sensor_sum += inductor1.read();
        right_sensor_sum += inductor2.read();
    }
    float left_sensor_avg = sqrt(left_sensor_sum/samples); // using square root but it lowkey works better by weighting further distances higher and reducing drastic dropoff
    float right_sensor_avg = sqrt(right_sensor_sum/samples);
   // printf("   left sensor: %3.3f", left_sensor_avg);
   // printf("   right sensor: %3.3f", right_sensor_avg);
   // printf("    error: %3.3f", left_sensor_avg-right_sensor_avg);
    //Off track detection
    if(left_sensor_avg < 0.05 && right_sensor_avg < 0.05) {
        targetSpeed = 0.0;
        programRunning = false;
        brakeCircuit.write(1);
    }

    feedback = (left_sensor_avg - right_sensor_avg + steering_bias_constant)/senSlope;
    
            
}

void get_driving_feedback() {
    // read left and right steering sensors
    float tach_sum = 0;
    int samples = 2;
    for (int i = 0; i < samples; i++) {
        tach_sum += driving_sensor.read();
    }
    float tach_sum_avg = tach_sum/samples;

    current_speed = tach_sum_avg;
    //printf("    Measured Speed: %f", current_speed);   
}

// Main driving function called by the ticker
void drivingUpdate() {
   // Static variables to store values between function calls
   static float area_prior = 0.0f;
   static float error_prior = 0.0f;
   
   // Read sensor feedback and user-defined reference
   float reference = targetSpeed;
   
   // Calculate the current error
   error_current = reference - current_speed;
   
   // Calculate the PID controller output
   output = calculatePIDOutput(TI_driving, error_current, error_prior, area_prior, KP_driving, KI_driving, KD_driving);
   
   // Bound the output to the PWM range [0.0, 1.0]
   bound_output = (fmax(0.0f, fmin(output, 1.0f)));
   
   // Set the PWM duty cycle
   control_output.write(reference + bound_output);
   
   // Update prior error for the next iteration
   error_prior = error_current;
}

// Main steering function called by the ticker
void steeringUpdate()
{
    error_current_steering = reference - feedback;
    integralSum += error_current_steering*TI_steering;
    errorChange = (error_current_steering - previousError)/TI_steering; // Euler approximation of derivative
    controlAction = calculatePIDOutput(TI_steering, error_current_steering, errorChange, integralSum, KP_steering, KI_steering, KD_steering);
    previousError = error_current_steering;
    
    float bound = 0.02;
    float bounded_controlAction = (fmax(-bound, fmin(controlAction, bound)));
    servo.write(center+bounded_controlAction);
}

void landmarkUpdate()
{
    if (programRunning){
        if ((num_left_landmarks == 0) && (num_right_landmarks == 0)){
            // integralSum = 0; // reset integral term to prevent windup
            targetSpeed = Sect3_speed;
            KP_steering = Sect3KP_steering;
            KI_steering = Sect3KI_steering;
            KD_steering = Sect3KD_steering;
            landmarkLED.write(0);
        }
        else if(num_left_landmarks == 0 && num_right_landmarks == 1){
            targetSpeed = Sect3_speed;
            KP_steering = Sect3KP_steering;
            KI_steering = Sect3KI_steering;
            KD_steering = Sect3KD_steering;
            landmarkLED.write(0);
        }
        else if(num_left_landmarks == 1 && num_right_landmarks == 1){
            brakeCircuit.write(0);
            targetSpeed = Sect3_speed;
            KP_steering = Sect3KP_steering;
            KI_steering = Sect3KI_steering;
            KD_steering = Sect3KD_steering;
            landmarkLED.write(0);
        }
        else if(num_left_landmarks == 1 && num_right_landmarks == 3){
            targetSpeed = Sect3_speed;
            KP_steering = Sect3KP_steering;
            KI_steering = Sect3KI_steering;
            KD_steering = Sect3KD_steering;
            landmarkLED.write(0);
        }
        else if(num_left_landmarks == 2 && num_right_landmarks == 3){
            targetSpeed = Sect3_speed;
            KP_steering = Sect3KP_steering;
            KI_steering = Sect3KI_steering;
            KD_steering = Sect3KD_steering;
            landmarkLED.write(0);
        }
        else if(num_left_landmarks == 3 && num_right_landmarks == 3){
            targetSpeed = Sect3_speed;
            KP_steering = Sect3KP_steering;
            KI_steering = Sect3KI_steering;
            KD_steering = Sect3KD_steering;
            landmarkLED.write(0);
        }
        else if(num_left_landmarks == 3 && num_right_landmarks == 4){
            
            targetSpeed = Sect3_speed;
            KP_steering = Sect3KP_steering;
            KI_steering = Sect3KI_steering;
            KD_steering = Sect3KD_steering;
            landmarkLED.write(0);
        }
        else if(num_left_landmarks == 4 && num_right_landmarks == 4){
            
            targetSpeed = Sect3_speed;
            KP_steering = Sect3KP_steering;
            KI_steering = Sect3KI_steering;
            KD_steering = Sect3KD_steering;
            landmarkLED.write(0);
        }
        else if(num_left_landmarks == 4 && num_right_landmarks == 5){
            
            targetSpeed = Sect3_speed;
            KP_steering = Sect3KP_steering;
            KI_steering = Sect3KI_steering;
            KD_steering = Sect3KD_steering;
            landmarkLED.write(0);
        }
        else if(num_left_landmarks == 5 && num_right_landmarks == 5){
            targetSpeed = Sect3_speed;
            KP_steering = Sect3KP_steering;
            KI_steering = Sect3KI_steering;
            KD_steering = Sect3KD_steering;
            landmarkLED.write(0);
        }
        else if(num_left_landmarks == 6 && num_right_landmarks == 6){
            targetSpeed = Sect3_speed;
            KP_steering = Sect3KP_steering;
            KI_steering = Sect3KI_steering;
            KD_steering = Sect3KD_steering;
            landmarkLED.write(1);
        }
    }
}

InterruptIn Button(BUTTON1);

void onButtonPress() {
    buttonPressed = true; // Set the flag when button is pressed
}

int main()
{
    servo.period_ms(20); // set servo frequency to 50 Hz (20 ms period)
    // Initialize steering Ticker
    Ticker steering_ticker;
    steering_ticker.attach(&steeringUpdate,TI_steering);
    // Initialize driving Ticker
    Ticker driving_ticker;
    driving_ticker.attach(&drivingUpdate, TI_driving);
    // Initialize landmark detection ticker
    Ticker landmark_ticker;
    landmark_ticker.attach(&landmarkUpdate, 1ms);

    Button.fall(&onButtonPress);

    while (true) {
        // Check if the button was pressed
        if (buttonPressed) {
            buttonPressed = false; // Reset the flag
            servo.write(center);

            // Toggle the program running state
            programRunning = !programRunning;

            if (programRunning) {
                printf("Button pressed! Starting program...\n");
                runLED.write(1);
                targetSpeed = slowSpeed;
                control_output.write(targetSpeed);
                brakeCircuit.write(0);
            } else {
                printf("Button pressed! Stopping program...\n");
                runLED.write(0);
                targetSpeed = 0.0;
                control_output.write(0.0);
                brakeCircuit.write(1);
            }
            
        }
        if (programRunning) {
            //stop program if bumpers are pressed
            if(left_bumper.read() == 0 || right_bumper.read() == 0){
                targetSpeed = 0.0;
                programRunning = false;
            }

            // read landmark sensors
            float left_landmark = detectLeft.read();
            float right_landmark = detectRight.read();

            // if both sensors don't detect a landmark, set landmark_detected to false
            if (right_landmark > 0.7 && left_landmark > 0.7){
                left_landmark_detected = false;
                right_landmark_detected = false;
                // landmarkLED.write(0);
            }
            // increment landmark counter if landmark is detected, but only if landmark was not previously detected
            if (left_landmark_detected == false && left_landmark < 0.4){
                num_left_landmarks += 1;
                left_landmark_detected = true;
                // landmarkLED.write(1);
            }
            // increment landmark counter if landmark is detected, but only if landmark was not previously detected
            if (right_landmark_detected == false && right_landmark < 0.4){
                num_right_landmarks += 1;
                right_landmark_detected = true;
                // landmarkLED.write(1);
            }

            printf("    left signal: %3.3f", detectLeft.read());
            printf("    right signal: %3.3f", detectRight.read());
            printf("    Left Landmark Count: %d", num_left_landmarks);
            printf("    Right Landmark Count: %d\n", num_right_landmarks);
            
            // read steering sensors
            // if (new_steering_update == true){
            //     get_steering_feedback();
            //     new_steering_update = false;
            // }
            get_steering_feedback();

            // read driving sensor
            get_driving_feedback();
            // printf("    left bumper: %d", left_bumper.read());
            // printf("    right bumper: %d", right_bumper.read());

            // printf("    PI Output: %f", output); 
            // printf("    Bounded Output: %f", bound_output);  
           // printf("    Set Speed: %f", targetSpeed);              
            // printf("    Error: %f", error_current);
            // printf("    left signal: %3.3f", detectLeft.read());
            // printf("    right signal: %3.3f", detectRight.read());
           // printf("   error: %3.3f", error_current_steering);
           // printf("   integral Term: %3.3f", integralSum*KI_steering);
           // printf("   u: %3.3f", controlAction);
           // printf("   servo position: %3.3f \n\n", servo.read());
             
        }
        else{
            runLED.write(0);
        }
    }
}
